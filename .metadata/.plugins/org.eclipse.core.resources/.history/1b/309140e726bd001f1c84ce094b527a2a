package tree;

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class BinaryTree extends Tree {

    public BinaryTree() {
        super();
    }

    @Override
    public void createTree(int value) {
        root = new Node(value);
    }

    @Override
    public void insertNode(Node parent, int value) {
        if (parent != null) {
            if (parent.getChildren().size() < 2) {
                Node newNode = new Node(value);
                parent.addChild(newNode);
            } else {
                System.out.println("Binary tree node can only have two children.");
            }
        }
    }

    @Override
    public Node search(int value) {
        return searchBFS(root, value);
    }

    private Node searchBFS(Node current, int value) {
        if (current == null) return null;

        Queue<Node> queue = new LinkedList<>();
        queue.add(current);

        while (!queue.isEmpty()) {
            Node node = queue.poll();
            if (node.getValue() == value) {
                return node;
            }
            queue.addAll(node.getChildren());
        }
        return null;
    }

    @Override
    public void deleteNode(int value) {
        Node nodeToDelete = search(value);
        if (nodeToDelete != null && nodeToDelete != root) {
            Node parent = nodeToDelete.getParent();  // Use the getter to access the parent
            if (parent != null) {
                parent.removeChild(nodeToDelete);  // Remove node from parent
            }
        }
    }

    @Override
    public void updateNode(int oldValue, int newValue) {
        Node node = search(oldValue);
        if (node != null) {
            node.setValue(newValue);
        }
    }

    @Override
    public List<Node> traverse(String algorithm) {
        if ("DFS".equals(algorithm)) {
            return traverseDFS();
        } else if ("BFS".equals(algorithm)) {
            return traverseBFS();
        }
        return new LinkedList<>();
    }

    public List<Node> traverseDFS() {
        List<Node> result = new LinkedList<>();
        if (root != null) {
            traverseDFSRecursive(root, result);
        }
        return result;
    }

    private void traverseDFSRecursive(Node current, List<Node> result) {
        result.add(current);
        for (Node child : current.getChildren()) {
            traverseDFSRecursive(child, result);
        }
    }

    public List<Node> traverseBFS() {
        List<Node> result = new LinkedList<>();
        if (root != null) {
            Queue<Node> queue = new LinkedList<>();
            queue.add(root);
            while (!queue.isEmpty()) {
                Node current = queue.poll();
                result.add(current);
                queue.addAll(current.getChildren());
            }
        }
        return result;
    }
}

