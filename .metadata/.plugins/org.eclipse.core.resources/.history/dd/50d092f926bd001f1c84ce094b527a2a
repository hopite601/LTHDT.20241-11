package tree;

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class BinaryTree extends Tree {

    public BinaryTree() {
        super();
    }

    @Override
    public void createTree(int value) {
        root = new Node(value);
    }

    @Override
    public void insertNode(Node parent, int value) {
        if (parent != null) {
            // Kiểm tra xem node hiện tại đã có 2 con chưa
            if (parent.getChildren().size() < 2) {
                Node newNode = new Node(value);
                parent.addChild(newNode);
            } else {
                System.out.println("A binary node can have only two children.");
            }
        }
    }

    @Override
    public Node search(int value) {
        return searchBFS(root, value);
    }

    private Node searchBFS(Node current, int value) {
        if (current == null) return null;

        // Duyệt theo chiều rộng (BFS) sử dụng Queue
        Queue<Node> queue = new LinkedList<>();
        queue.add(current);

        while (!queue.isEmpty()) {
            Node node = queue.poll();
            if (node.getValue() == value) {
                return node;
            }
            queue.addAll(node.getChildren());
        }
        return null;
    }

    @Override
    public void deleteNode(int value) {
        Node nodeToDelete = search(value);
        if (nodeToDelete != null && nodeToDelete != root) {
            Node parent = nodeToDelete.getParent();  // Dùng getter để lấy parent
            if (parent != null) {
                parent.removeChild(nodeToDelete);  // Xóa node khỏi parent
            }
        }
    }

    @Override
    public void updateNode(int oldValue, int newValue) {
        Node node = search(oldValue);
        if (node != null) {
            node.setValue(newValue);
        }
    }

    @Override
    public List<Node> traverse(String algorithm) {
        if ("DFS".equals(algorithm)) {
            return traverseDFS();
        } else if ("BFS".equals(algorithm)) {
            return traverseBFS();
        }
        return new LinkedList<>();
    }

    // Duyệt theo chiều sâu (DFS)
    public List<Node> traverseDFS() {
        List<Node> result = new LinkedList<>();
        if (root != null) {
            traverseDFSRecursive(root, result);
        }
        return result;
    }

    private void traverseDFSRecursive(Node current, List<Node> result) {
        result.add(current);  // Thêm node hiện tại vào kết quả
        for (Node child : current.getChildren()) {
            traverseDFSRecursive(child, result);  // Duyệt tiếp các con của node hiện tại
        }
    }

    // Duyệt theo chiều rộng (BFS)
    public List<Node> traverseBFS() {
        List<Node> result = new LinkedList<>();
        if (root != null) {
            Queue<Node> queue = new LinkedList<>();
            queue.add(root);
            while (!queue.isEmpty()) {
                Node current = queue.poll();
                result.add(current);
                queue.addAll(current.getChildren());
            }
        }
        return result;
    }
}
